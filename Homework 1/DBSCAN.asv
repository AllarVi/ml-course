classdef DBSCAN
    methods(Static)
        function neighbors = RangeQuery(points, Q, eps)
            neighbors = Point.empty;
            i_n = 1;
            for i = 1:length(points)
                if Distance.eucl(Q.position, points(i).position) <= eps
                    neighbors(i_n) = points(i);
                    i_n = i_n + 1;
                end
            end
        end
         
        function DB = execute(DB, eps, minPts)
            C = 0; % Cluster counter
            for pointIDX = 1:length(DB)
                point = DB(pointIDX);
                
                if point.label ~= 0 % Previously processed in inner loop
                    continue;
                end
                
                neighbors = DBSCAN.RangeQuery(DB, point, eps); % Find neighbors
                if length(neighbors) < minPts
                    DB(pointIDX).label = -1; % Label as Noise
                    continue;
                end
                C = C + 1; % next cluster label
                DB(pointIDX).label = C; % Label initial point
                
                mask = arrayfun(@(x) ~isequal(x.position, DB(pointIDX).position), neighbors);
                seedSet = neighbors(mask); % Neighbors to expand
                
                seedPointIDX = 1;
                while seedPointIDX <= length(seedSet) % Process every seed point
                    seedPoint = seedSet(seedPointIDX);
                    
                    if seedPoint.label == -1
                        DB(pointIDX).label = C; % Change Noise to border point
                    end
                    
                    if seedPoint.label ~= 0 % Previously processed
                        continue;
                    end
                    
                    DB(pointIDX).label = C; % Label neighbor
                    n_neighbors = DBSCAN.RangeQuery(DB, seedPoint, eps);
                    if length(n_neighbors) >= minPts
                        % S = S ? N
                    end
                end
            end
        end
        
    end
end